name: Publish Go
run-name: ${{ github.workflow }}

on:
  push:
    branches:
      - main
    paths:
      - "go/**"
  workflow_dispatch:

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"

      - name: Set Matrix
        id: set-matrix
        run: |
          set -e
          matrix=()

          for dir in go/*; do
            if [ ! -f "$dir/go.mod" ]; then continue; fi
            if [ ! -f "$dir/go.version" ]; then continue; fi

            pushd "$dir" >/dev/null || continue
            name="$(go list -m)"
            version="$(head -n 1 go.version)"
            popd >/dev/null || continue

            if [ -z "$name" ]; then continue; fi
            if [ -z "$version" ]; then continue; fi

            matrix+=("$dir")
          done

          matrix_json=$(jq --compact-output --null-input '$ARGS.positional' --args -- "${matrix[@]}")
          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT

  publish:
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      max-parallel: 1
      matrix:
        package-path: ${{ fromJson(needs.prepare.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Required to check existing tags
          fetch-depth: 0
          # Required to push tags
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      - uses: actions/setup-go@v6
        with:
          go-version: "1.25"

      - name: Restore Dependencies
        working-directory: ${{ matrix.package-path }}
        run: |
          set -xe
          go mod tidy

          if [ ! -z "$(git status --porcelain -- go.mod go.sum)" ]; then
            echo "Go module was not tidy."
            exit 1
          fi

      - name: Test
        working-directory: ${{ matrix.package-path }}
        run: go test -v -count=1 ./...

      - name: Publish
        working-directory: ${{ matrix.package-path }}
        run: |
          set -e
          dir="${{ matrix.package-path }}"
          name="$(go list -m)"
          version="$(head -n 1 go.version)"

          # The tag includes the repo subdirectory when publishing go packages
          # in a monorepo.
          tag="${dir}/v${version}"

          if [ ! -z "$(git tag -l "$tag")" ]; then
            echo "$tag already published. skipping."
            exit
          fi

          git tag "$tag"
          git push origin tag "$tag"

          # Making a Go module "available" is just a matter of asking the
          # proxy for it once. This doesn't always seem to work immediately,
          # so we retry a couple of times (3) with a delay (5s) if it fails.
          # See: https://go.dev/doc/modules/publishing#publishing-steps
          for i in {1..3}; do
            sleep 5
            if GOPROXY=proxy.golang.org go list -m "${name}@v${version}" &>/dev/null; then
              continue
            fi
          done
